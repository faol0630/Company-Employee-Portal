
Antes de empezar en pom.xml debe estar la dependency de spring security:

    <dependency>
    			<groupId>org.springframework.boot</groupId>
    			<artifactId>spring-boot-starter-security</artifactId>
    </dependency>

    debemos tener un Entity que tenga un atributo username y un atributo password.

    En el atributo password usamos PasswordEncoder para encriptarlo, cosa de que
    cuando se creen Objetos de ese Entity ya esten con el password encriptado.
    (ejecutar paso 16).

    Tambien podriamos ejecutar el paso 19 agregar dependencies de JWT.


1) En EmployeeRepository agregamos el siguiente metodo:

    Optional<Employee> findByUsername(String username);

2) crear paquete auth

3) dentro de auth, crear la class SpringSecurityConfig

4) dentro de auth crear el paquete filters

5) dentro de auth creamos la class TokenJwtConfig, que va a contener constantes que vamos a usar en las
    class JwtAuthFilter(se crea en el prox paso) y JwtValidationFilter(se crea mas adelante). esta class
    tiene esta forma:

    public class TokenJwtConfig {

        //constantes usadas solo en las clases JwtValidationFilter y JwtAuthFilter:
        public final static String SECRET_KEY =  "token_creado_por_usuario";
        public final static String PREFIX_TOKEN =  "Bearer ";
        public final static String HEADER_AUTH =  "Authorization";
        public final static String CONTENT_TYPE =  "application/json";


    }

6) dentro de filters crear la class JwtAuthFilter

7) en la class SpringSecurityConfig declaramos el siguiente atributo:

    @Autowired
    private AuthenticationConfiguration authenticationConfiguration;

8) en la misma class SpringSecurityConfig dentro del metodo filterChain, agregar la siguiente linea:

    .addFilter(new JwtAuthFilter(authenticationConfiguration.getAuthenticationManager()))

9) tambien en la class SpringSecurityConfig agregar el siguiente metodo para poder probar nuestra app:

        @Bean
        PasswordEncoder passwordEncoder(){
            return NoOpPasswordEncoder.getInstance();
        }

10) dentro de service o dentro de auth crear la class JpaUserDetailsService

        Cuando se cree la class JpaUserDetailsService
        del paso 10, se puede crear con la logica que va a llevar al final (paso 18),
        lo que hace innecesario la ejecucion del paso11 y el comentario del paso 10.
        Hacemos la prueba directo con el username y el password de cada entity sin tener
        que usar admin y 12345.

En este punto hacemos una prueba con postman en donde en el endpoint localhost:8080/login
pasamos como user : "admin" y password : "12345" y esto nos debe devolver el token provisional que hemos creado.
Este token será reemplazado mas adelante por un jwt.

11) implementacion de BCryptPasswordEncoder: en la class JpaUserDetailsService dentro del metodo loadUserByUsername
    el password que tenemos como 12345 lo reemplazamos con
    "$2a$10$DOMDxjYyfZ/e7RcBfUpzqeaCs8pLgcizuiQWXPkU35nOhZlFcE9MS"

    esto es un password del tipo BCryptPasswordEncoder que estamos generando manualmente mientras terminamos
    la implementacion.

12) en la class SpringSecurityConfig creamos el siguiente metodo:

        @Bean
        AuthenticationManager authenticationManager() throws Exception{
            return authenticationConfiguration.getAuthenticationManager();
        }

13) en el metodo passwordEncoder de la misma class SpringSecurityConfig cambiamos el contenido reemplazando
    passwordEncoder por BCryptPasswordEncoder():

        @Bean
        PasswordEncoder passwordEncoder(){
            return new BCryptPasswordEncoder();
        }

En este punto volvemos a probar la app.Deberia funcionar igual que la prueba anterior.

14) dentro del paquete auth.filters creamos la class JwtValidationFilter.

15) en la class SpringSecurityConfig agregamos el filter de la recien creada class JwtValidationFilter:

    .addFilter(new JwtValidationFilter(authenticationConfiguration.getAuthenticationManager()))


En este punto se puede hacer una prueba pasando el token que resulta de ejecutar el POST:

    POST http://localhost:8080/login en donde en el body pasamos:

    {
      "username": "admin",
      "password": "12345"
    }

    esto devuelve algo como :

    {
      "message": "Hello admin, successful login",
      "token": "dG9rZW5fY3JlYWRvX3Bvcl91c3VhcmlvOmFkbWlu",
      "username": "admin"
    }

    con el token de la respuesta anterior pasandolo via Auth Bearer , ejecutamos los demas endpoints.si
    todo ha sido bien hecho, no se deberia tener ningun problema.

16) en la class ServiceImpl declaramos Password encoder :

        @Autowired
        PasswordEncoder passwordEncoder;

    en el metodo save o createNewEmployee, encriptamos el password haciendo algo como :


        @Override
        public void newEmployee(Employee employee){
            String passwordBCrypt = passwordEncoder.encode(employee.getPassword());
            employee.setPassword(passwordBCrypt);
            employeeRepo.save(employee);
        }

    tanto el password sin encriptar como el password encriptado son String , asi que esto no genera
    ningun problema.

17) en la base de datos (mysql en este caso) debemos borrar todas las tuplas y volver a crearlas pero
    esta vez ya estaran con el password encriptado.

    En este se puede volver a probar la app , creando nuevos employee y si todo está bien , deben crearse
    con el password debidamente encriptado.Todavia seguimos usando el token que obtenemos con username
    admin y password 12345 ya que esa parte aun no se ha configurado.



18) En JpaUserDetailsService , debido a que es un @Service , inyectamos el repository:

        @Autowired
        private EmployeeRepo employeeRepo;

        reemplazamos la logica del metodo loadUserByUsername por :

                Optional<Employee> employeeOptional = employeeRepo.findByUsername(username);

                if (!employeeOptional.isPresent()){
                    throw new UsernameNotFoundException(String.format("Username %s not found", username));
                }

                Employee employee = employeeOptional.orElseThrow();

                List<GrantedAuthority> authorities = new ArrayList<>();
                authorities.add(new SimpleGrantedAuthority("ROLE_USER"));

                return new User(//este User viene con spring framework.No es un entity que hayamos creado.
                        employee.getUsername(),
                        employee.getPassword(),
                        true,
                        true,
                        true,
                        true,
                        authorities
                );

        con esta logica, los password creados con los Employees van a ser los password para hacer login.

19) Empezamos con JWT. agregamos 3 dependencies a pom.xml :

            <dependency>
    			<groupId>io.jsonwebtoken</groupId>
    			<artifactId>jjwt-api</artifactId>
    			<version>0.11.5</version>
    		</dependency>

    		<dependency>
    			<groupId>io.jsonwebtoken</groupId>
    			<artifactId>jjwt-impl</artifactId>
    			<version>0.11.5</version>
    			<scope>runtime</scope>
    		</dependency>

    		<dependency>
    			<groupId>io.jsonwebtoken</groupId>
    			<artifactId>jjwt-jackson</artifactId>
    			<version>0.11.5</version>
    			<scope>runtime</scope>
    		</dependency>

20) en la class TokenJwtConfig modificamos la constante SECRET_KEY:

    public final static Key SECRET_KEY =  Keys.secretKeyFor(SignatureAlgorithm.HS256);

21) en la class JwtAuthFilter dentro del metodo successfulAuthentication, reemplazamos el token
provisional que habiamos creado con un token JWT :

    String token = Jwts.builder()
                    .setSubject(username)
                    .signWith(SECRET_KEY)
                    .setIssuedAt(new Date())
                    .setExpiration(new Date(System.currentTimeMillis() + 3600000))
                    .compact();

22) en la class JwtValidationFilter dentro del metodo doFilterInternal,
    el if else lo convertimos en un try catch.quitamos las 5 lineas anteriores a dicho try catch.
    el codigo dentro del metodo doFilterInternal queda asi :


            String header = request.getHeader(HEADER_AUTH);

            if (header == null || !header.startsWith(PREFIX_TOKEN)){
                chain.doFilter(request, response);
                return;
            }

            String token = header.replace(PREFIX_TOKEN, "");

            try{
                //validando el token:
                Claims claims = Jwts.parserBuilder().setSigningKey(SECRET_KEY)
                        .build()
                        .parseClaimsJws(token)
                        .getBody();

                String username = claims.getSubject();

                List<GrantedAuthority> authorities = new ArrayList<>();
                authorities.add(new SimpleGrantedAuthority("ROLE_USER"));

                UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(username, null, authorities);
                SecurityContextHolder.getContext().setAuthentication(authenticationToken); //autenticacion
                chain.doFilter(request,response);

            }catch (JwtException e){

                Map<String, String> body = new HashMap<>();//string string porque solo va a pasar mensajes de error
                body.put("error", e.getMessage());
                body.put("message", "Invalid jwt token");
                response.getWriter().write(new ObjectMapper().writeValueAsString(body));
                response.setStatus(403);
                response.setContentType(CONTENT_TYPE);

            }

23)








